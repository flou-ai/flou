{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Flou","text":"<p>Flou is the framework for building LLM-powered apps. It enables you to prototype, iterate and optimize your app efficiently to achieve the best performance.</p> <p>Flou introduces a structured development approach through three main components:</p> <ul> <li> <p>Network of Agents: A formal data model based on declarative state machines designed to represent any complex (or PoC) workflow while maintaining clean code and enabling easy experimentation.(1)</p> <ol> <li> <ul> <li>decouples your LLM-related code from the rest of your application</li> <li>concurrency and nesting out-of-the-box</li> <li>code-first approach accompanied by a visual representation</li> </ul> </li> </ol> </li> <li> <p>Orchestration Engine: Abstracts infrastructure and orchestration logic providing an API to execute your Network of Agents similar to how you interact with plain LLMs. Supports state management, storage and traceability.(1)</p> <ol> <li> <ul> <li>provides a Time Machine that saves a snapshot for every state execution and transition, allowing inspection, replay and rewind</li> <li>efficient execution with out-of-the-box error management and retries</li> <li>communicate via websockets, REST API, python code or CLI</li> <li>easily integrates with your CI/CD</li> </ul> </li> </ol> </li> <li> <p>Studio: An IDE designed around the development UX and best practices for developing with LLMs. It supports observability, experimentation, performance evaluation, testing and monitoring, creating a streamlined development cycle from prototyping to production.(1)</p> <ol> <li> <ul> <li>visual representation of Network of Agents and execution history</li> <li>production inspection and monitoring</li> <li>playground for manual interactions</li> <li>dataset, annotations and evaluators management</li> <li>experiments tracking</li> </ul> </li> </ol> </li> </ul>"},{"location":"#why-flou","title":"Why Flou?","text":"<p>Flou was designed after building production LLM powered apps, learning best practices, reading academia research and extracting internal tools.</p>"},{"location":"#deterministic-coding-prompt-engineering","title":"Deterministic coding \u27f6 Prompt engineering","text":"<p>Developing on top of LLMs introduced a new paradigm that shifts the old deterministic substrate into a stochastic one without established best practices. This results in developers blindly iterating via trial and error.</p> <p>Flou provides a systematic and rigorous approach to effectively guide and tackle performance challenges via its experiment tracking.</p>"},{"location":"#software-design-network-of-agents","title":"Software design \u27f6 Network of Agents","text":"<p>Most LLM-powered apps embark on solving a narrow/specific problem which traditional software design cannot handle and neither naive usage of LLMs. Taking SotA LLMs to the limits of their capabilities to solve more difficult problems means continuously and aggressively experimenting your Network of Agents.</p> <p>Flou provides the best orchestration foundational layer to iterate over any network structure applying new techniques and patterns from the simplest ones to the most complex workflows. Flou's Network of Agents allows you to express ideas in an elegant way reducing spaghetti code and accelerating iteration.</p>"},{"location":"#established-frameworks-fragmented-ecosystem","title":"Established frameworks \u27f6 Fragmented ecosystem","text":"<p>The AI ecosystem is completely fragmented full of niche and narrow tools. To develop a project you need to analyze, test and choose a set of tools that don't play nicely with one another. You often end up a prisoner of locked proprietary platforms and reinventing the wheel with in-house solutions.</p> <p>Flou is an open-source opinionated unified framework that helps you develop throughout the whole development cycle from a PoC to a production grade performance app to maintenance. It's philosophy is modular so you can choose how much or how little of Flou you want to use.</p> <p>You can start your project from scratch in Flou or migrate just a small critical piece of your exiting app that needs performance improvements.</p>"},{"location":"#sporadic-disruptive-updates-frequent-disruptive-changes","title":"Sporadic disruptive updates \u27f6 Frequent disruptive changes","text":"<p>In the current AI boom new models, checkpoints and academic techniques are rapidly released in an unprecedented fashion. To avoid becoming obsolete you need to stay ahead of the curve.</p> <p>Flou allows you to capitalize on these frequent disruptions by making it's evaluation platform a core component and providing functional E2E tests and performance monitoring.</p>"},{"location":"documentation/","title":"Welcome to the Flou Documentation","text":"<p>Here you will find everything you need to know about Flou. It's been designed to be read in order, skipping any advanced section you may want and then be used as reference.</p> <p>The documentation is divided in the following sections:</p> <ul> <li> <p>Getting Started: Get up and running with your first Flou project and interacting with it in the Studio.</p> </li> <li> <p>Network of Agents: Flou's data model. Learn how to express your workflows with our State Machines, with nesting and concurrency out-of-the-box.</p> </li> <li> <p>Studio: Iterate your solution and monitor your deployment.</p> </li> <li> <p>Orchestration Engine: How to [configure](engine/dependencies.md] your execution environment and run your Network of Agents via our REST API &amp; CLI, websockets.</p> </li> <li> <p>Contributing: Need help? Found a bug? Want to learn more about Flou's internals? This section is for you.</p> </li> </ul>"},{"location":"documentation/changelog/","title":"Changelog","text":""},{"location":"documentation/changelog/#flou-v01","title":"Flou v0.1","text":"<p>Initial public release.</p>"},{"location":"documentation/quicksheet/","title":"Quicksheet","text":""},{"location":"documentation/quicksheet/#installing-and-running","title":"Installing and running","text":"<pre><code>pip install flou\ntouch app.py\ntouch requirements.txt\ntouch .env\nflou compose up\n</code></pre>"},{"location":"documentation/quicksheet/#ltms","title":"LTMs","text":"<pre><code>from flou import LTM\nfrom flou.registry import registry\n\n\nclass MyState(LTM):\n    name = 'my_state'\n\n    def run(self, **params):\n        label = 'my_transition'\n        params = {}\n        self.transition(label, **params)\n\n        self.update_state({'internal_state_key': 'state_value'})\n        self.root.update_state({'global_key': 'global_value'})\n\n        print(self.state['internal_state_key'])  # prints 'state_value'\n        print(self.root.state['global_key'])  # prints 'global_value'\n\nclass EndState(LTM):\n    def run(self, **params):\n        print('end')\n\n\nclass MyNetwork(LTM):\n    name = 'my_ltm'\n    init = [MyState]\u00a0 # init can be simple states or sub machines\n    transitions = [\n        {'from': MyState, label: 'my_transition', 'to': EndState}\n    ]\n\nregistry.register(MyNetwork)\n</code></pre> <ul> <li><code>LTM.name</code>: the name of the ltm. Allowed names: <code>^[a-z][a-z0-9_]*$</code></li> <li><code>LTM.init</code>: start these ltms when the current one is executed</li> <li><code>LTM.transitions</code>: list of <code>{'from': FromLTMClass, 'label': transition_label, 'to': ToLTMClass}</code> <code>from</code> and <code>to</code> can be a single class or an iterable of classes</li> <li><code>LTM.start()</code>: start the root LTM, should be called only once</li> <li><code>LTM.root</code>: returns the <code>root</code> LTM</li> <li><code>LTM.parent</code>: returns the <code>parent</code> LTM</li> <li><code>LTM.state</code>: returns a dict with the current LTM state, you can use <code>self.root.state</code> for global state. Don't assign directly, see <code>LTM.update_state</code></li> <li><code>LTM.update_state(update_list)</code>: pass a list of <code>{key: value}</code> to update the state. Use <code>self.root.update_state</code> to update the global state</li> <li><code>LTM.atomic_state_append(key, value)</code>: atomically and immediately append <code>value</code> to a pre initialized list <code>key</code> in <code>self.state</code>. Use only in concurrent states.</li> <li><code>LTM.transition(label, payload, params, namespace)</code>: transition all LTMS with <code>label</code> transition</li> </ul>"},{"location":"documentation/contributing/","title":"Contributing","text":"<p>The contributing docs contains documentation on internals and processes used by the dev team.</p>"},{"location":"documentation/contributing/#bugs-feature-requests-help-and-chat","title":"Bugs, feature requests, help and chat","text":"<p>For bug reporting and feature requests please use the github issues. Before creating a new issue please be sure to search among existing issues.</p> <p>For questions and help please use the github discussions.</p> <p>For a quick chat, join us on our discord server.</p>"},{"location":"documentation/contributing/#architecture","title":"Architecture","text":"<p>Flou is structured as a monorepo, containing all the core components that make up the system:</p> <ul> <li>Flou Engine: a Python project that runs a task queue (celery) for running   concurrent tasks.</li> <li>Flou Api: a FastAPI Python project that share's code with the Engine.</li> <li>Flou Studio: a SvelteKit project</li> <li>Flou Docs: a MKDocs project</li> </ul> <p>Each runs it's own process detailed in setting up a development environment.</p>"},{"location":"documentation/contributing/dev-environment/","title":"Setting up a local dev environment","text":"<p>To start contributing to flou create a local python &amp; node environment and install all the dependencies by following these steps.</p> <ol> <li> <p>Clone this repo:</p> <pre><code>% git clone https://github.com/flou-ai/flou/\n% cd flou\n</code></pre> </li> <li> <p>Create a python virtual environment:</p> <pre><code>% python -m venv venv\n% source venv/bin/activate\n</code></pre> <p>Whenever you start a new terminal start the virtualenv with <code>source venv/bin/activate</code>.</p> </li> <li> <p>Install the python dev dependencies:</p> <pre><code>(venv) %\u00a0cd flou\n(venv) %\u00a0pip install -r requirements-dev.txt\n(venv) % cd ..\n</code></pre> </li> <li> <p>Install a local javascript node env and install the js dependencies.</p> <pre><code>(venv) % nodeenv -p\n(venv) % source venv/bin/activate\n(venv) % cd studio\n(venv) % npm install\n(venv) % cd ..\n</code></pre> <p>Note that the <code>venv</code> needs to be re-activated just after installing &gt; <code>nodeenv</code> in order to activate it this first time.</p> </li> <li> <p>Install the docs requirements</p> <pre><code>(venv) % cd ../docs\n(venv) % pip install -r requirements.txt\n(venv) % cd ..\n</code></pre> </li> </ol>"},{"location":"documentation/contributing/dev-environment/#running-flou-for-contributing","title":"Running Flou for contributing","text":"<p>We need to run each part of Flou in it's own terminal.</p> <ol> <li> <p>You will need a local redis and postgresql instance. If you don't want to install them locally you can run them via docker.</p> <pre><code>% docker compose up db cache\n</code></pre> </li> <li> <p>To run the api and engine you will need to create a sample Flou project.</p> <ul> <li> <p>Run the Flou Api and visit http://localhost:8000/docs :</p> <pre><code>% cd my_flou_project\n% source venv/bin/activate\n(venv) % flou run api\n</code></pre> </li> <li> <p>Run the Flou Engine:</p> <pre><code>% cd my_flou_project\n% source venv/bin/activate\n(venv) % flou run engine\n</code></pre> </li> </ul> </li> <li> <p>For the Studio and Docs go to the flou repo:</p> <ul> <li> <p>Run the Flou Studio and visit http://localhost:8001 :</p> <pre><code>% source venv/bin/activate\n(venv) % cd flou/studio\n(venv) % npm run dev -- --port 8001\n</code></pre> </li> <li> <p>Run the Flou Docs and visit http://localhost:8002 :</p> <pre><code>% source venv/bin/activate\n(venv) % cd flou/docs\n(venv) % mkdocs serve -a 0.0.0.0:8002\n</code></pre> </li> </ul> </li> </ol>"},{"location":"documentation/contributing/docker-registry/","title":"Docker registry","text":"<p>Flou uses docker and it's hub as the preferred way to develop and deploy Flou apps. Here are the process and options to build, test and deploy Flou's docker images.</p>"},{"location":"documentation/contributing/docker-registry/#running-the-images-from-the-local-flou-repo","title":"Running the images from the local Flou repo","text":"<p>You need to override the default <code>compose.yml</code> so that it builds the images from the local source code instead of pulling them from the registry:</p> <pre><code>% docker compose -f compose.yml -f compose.dev.yml up\n</code></pre>"},{"location":"documentation/contributing/docker-registry/#building-and-deploying-the-images","title":"Building and deploying the images","text":"<p>To build, tag and push the images use:</p> <pre><code>% docker compose -f compose.yml -f compose.dev.yml build\n\n% docker tag flou-engine:latest flouai/flou:latest\n% docker tag flou-studio:latest flouai/studio:latest\n% docker tag flou-docs:latest flouai/docs:latest\n\n% docker push flouai/flou:latest\n% docker push flouai/studio:latest\n% docker push flouai/docs:latest\n</code></pre>"},{"location":"documentation/contributing/docker-registry/#creating-a-local-docker-registry-for-testing","title":"Creating a local docker registry for testing","text":"<p>Creating a local docker registry can be useful for testing release procedures.</p> <p>We will be following this guide to set up the local registry using docker.</p>"},{"location":"documentation/contributing/docker-registry/#set-up-your-local-docker-registry","title":"Set up your local docker registry","text":"<p>First start your docker daemon and then run:</p> <pre><code>% docker run -d -p 5001:5000 --name registry registry:2.7\n</code></pre> <p>If you need to see the logs:</p> <pre><code>% docker logs -f registry\n</code></pre> <p>If you want a nice UI to see the registry instead run the <code>compose.yml</code> defined in this image adding to <code>registry-server</code>:</p> <pre><code>    ports:\n      - 5001:5000\n</code></pre>"},{"location":"documentation/contributing/docker-registry/#using-the-local-registry","title":"Using the local registry","text":"<p>After building the docker image use the following instructions to tag, push and pull from the local repository.</p> <pre><code>% docker compose -f compose.yml -f compose.dev.yml build\n% docker tag flou-engine:latest localhost:5001/flouai/flou:latest\n% docker push localhost:5001/flouai/flou:latest\n% docker pull localhost:5001/flouai/flou\n</code></pre> <p>The same can be done for the studio changing <code>engine</code> for <code>studio</code> or <code>docs</code>.</p> <pre><code>% docker tag flou-engine:latest localhost:5001/flouai/flou:latest\n% docker tag flou-studio:latest localhost:5001/flouai/studio:latest\n% docker tag flou-docs:latest localhost:5001/flouai/docs:latest\n% docker push localhost:5001/flouai/flou:latest\n% docker push localhost:5001/flouai/studio:latest\n% docker push localhost:5001/flouai/docs:latest\n</code></pre> <p>To the use this images in <code>flou compose</code> add the <code>REGISTRY</code> envvar to point to the local registry:</p> <pre><code>% REGISTRY=localhost:5001/ flou compose up\n</code></pre> <p>This overrides the default <code>compose.yml</code> file by changing the <code>build</code> property to an <code>image</code> pointing to the local registry and adding local volumes for developing.</p>"},{"location":"documentation/contributing/release-procedure/","title":"Release procedure","text":"<p>This document specifies how to create a new release of Flou.</p> <p>A release is compose of these steps:</p> <ol> <li>Check and update the Changelog</li> <li>Update the version for releasing</li> <li>Publish the new docker images</li> <li>Publish the python package to PyPI</li> <li>Advance the release version</li> </ol>"},{"location":"documentation/contributing/release-procedure/#updating-the-version","title":"Updating the version","text":"<p>Flou follows Semantic Versioning (SemVer) versioning.</p> <p>Flou is in early development, expect the Public API to evolve</p> <p>While in rapid development Flou will stay in 0 major version indicating that its public API may be subject to changes while we experiment and release new features. Expect the API to break.</p> <p>You can find the current version in the <code>pyproject.toml</code> file.</p> <p>Flou will be released in <code>stable</code> and <code>dev</code>. Every release with a <code>-dev.X</code> suffix means it's in active development and should not be used except to try experimental features. Before releasing a <code>stable</code> release, remove the <code>dev</code> suffix, publish the changes and then advance the minor or patch version and add the <code>dev</code> suffix again.</p>"},{"location":"documentation/contributing/release-procedure/#updating-the-docker-images","title":"Updating the docker images","text":"<pre><code>    % export FLOU_VERSION=0.1.0-dev.1\n    % docker compose -f compose.yml -f compose.dev.yml build\n\n    % docker tag flou-engine:latest flouai/flou:latest\n    % docker tag flou-studio:latest flouai/studio:latest\n    % docker tag flou-docs:latest flouai/docs:latest\n    % docker tag flou-engine:latest flouai/flou:$FLOU_VERSION\n    % docker tag flou-studio:latest flouai/studio:$FLOU_VERSION\n    % docker tag flou-docs:latest flouai/docs:$FLOU_VERSION\n\n    % docker push flouai/flou:latest\n    % docker push flouai/studio:latest\n    % docker push flouai/docs:latest\n    % docker push flouai/flou:$FLOU_VERSION\n    % docker push flouai/studio:$FLOU_VERSION\n    % docker push flouai/docs:$FLOU_VERSION\n</code></pre>"},{"location":"documentation/contributing/release-procedure/#updating-the-python-package-in-pypi","title":"Updating the python package in PyPI","text":"<p>Make sure you have your PyPI credentials set in <code>~/.pypirc</code>.</p> <ol> <li> <p>Build the package:</p> <pre><code>python3 -m build\n</code></pre> </li> <li> <p>Upload it to PyPI:</p> <pre><code>python3 -m twine upload dist/*\n</code></pre> </li> <li> <p>Check that the python package has been uploaded correctly.</p> </li> </ol>"},{"location":"documentation/engine/","title":"Orchestration Engine","text":"<p>The Flou Engine abstracts all the infrastructure needed for orchestrating Flou's Networks of Agents. It provides state management, efficient concurrency, error handling, retries, a time machine (an execution history with replay and rewind) and data storage out-of-the-box.</p> <p>It provides several APIs best suited for different use cases:</p> <ul> <li>A REST API similar to that of LLM providers</li> <li>CLI for development UX, scripts and easy CI/DC integration</li> <li>Websockets for realtime updates</li> </ul> <p>You can create many instances of a Network of Agents. An instance is the fixed structure defined in your code plus a status for each LTM (State Machine / State) and a store. You interact with the Network of Agents by performing labelled transitions and waiting for other transitions to run.</p> <p>Every time a transition is performed or a state get's executed a snapshot is taken so it's possible to inspect and trace the whole execution history at any point in time. It also allows for rollbacks to a previous snapshot and replays.</p>"},{"location":"documentation/engine/api-cli/","title":"Using the REST API &amp; CLI","text":"<p>You have two choices to interact with Flou's Engine, a REST API and the CLI. They have the same capabilities but are suited for different use cases.</p>"},{"location":"documentation/engine/api-cli/#rest-api-reference-documentation","title":"REST API reference documentation","text":"<p>You can visit http://localhost:8000/docs and check out the complete REST API reference documentation.</p>"},{"location":"documentation/engine/api-cli/#command-line-interface-help","title":"Command Line Interface help","text":"<p>By calling <code>flou --help</code> from your terminal you can see all the cli commands.</p>"},{"location":"documentation/engine/api-cli/#listing-registered-ltms","title":"Listing registered LTMs","text":"<p>To create a LTM you will need to know it's FQN (Fully Qualified Name) of the Python class. You can get it by listing all your registered LTMs:</p> REST APICLI <pre><code>curl -X 'GET' \\\n    'http://localhost:8000/api/v0/ltm/registry' \\\n    -H 'accept: application/json'\n</code></pre> Sample output<pre><code>[\n    {\n        \"fqn\": \"flou.app.SampleLTM\",\n        \"name\": \"sample_ltm\"\n    }\n]\n</code></pre> <pre><code>flou registry\n</code></pre> Sample output<pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name       \u2503 fqn                \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 sample_ltm \u2502 flou.app.SampleLTM \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"documentation/engine/api-cli/#creating-an-ltm-instance","title":"Creating an LTM instance","text":"<p>You can then create a new instance with the <code>FQN</code> and possible <code>payload</code>:</p> REST APICLI <pre><code>curl -X 'POST' \\\n    'http://localhost:8000/api/v0/ltm' \\\n    -H 'accept: application/json' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n        \"fqn\": \"flou.app.SampleLTM\",\n        \"payload\": {}\n    }'\n</code></pre> Sample output<pre><code>{\n    \"id\": 1\n}\n</code></pre> <pre><code>flou create flou.app.SampleLTM\n</code></pre> Sample output<pre><code>Created LTM root, id: 1, kwargs: {}\n</code></pre> <p>Creating an LTM returns a unique id across all Networks of Agents.</p>"},{"location":"documentation/engine/api-cli/#listing-all-ltms","title":"Listing all LTMs","text":"<p>You can list all the LTM's instances by:</p> REST APICLI <pre><code>curl -X 'GET' \\\n    'http://localhost:8000/api/v0/ltm' \\\n    -H 'accept: application/json'\n</code></pre> Sample output<pre><code>[\n    {\n        \"id\": 1,\n        \"name\": \"sample_ltm\",\n        \"fqn\": \"flou.app.SampleLTM\",\n        \"snapshots_count\": 1,\n        \"created_at\": \"2024-09-01 21:32:43\",\n        \"updated_at\": \"2024-09-01 21:32:43\"\n    }\n]\n</code></pre> <pre><code>flou get 1\n</code></pre> Sample output<pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id  \u2503 name       \u2503 fqn                \u2503 #snapshots \u2503 created_at          \u2503 updated_at          \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 1   \u2502 sample_ltm \u2502 flou.app.SampleLTM \u2502 1          \u2502 2024-09-01 21:32:43 \u2502 2024-09-01 21:32:43 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"documentation/engine/api-cli/#retrieving-an-instance","title":"Retrieving an instance","text":"<p>You will need the instance ID and call:</p> REST APICLI <pre><code>curl -X 'GET' \\\n    'http://localhost:8000/api/v0/ltm/1' \\\n    -H 'accept: application/json'\n</code></pre> Sample output<pre><code>{\n    \"name\": \"sample_ltm\",\n    \"state\": {\n        \"_status\": \"active\",\n        ...\n    },\n    \"snapshots\": [\n        {\n        \"time\": \"2024-09-01 18:32:43.473991\",\n        \"reason\": \"start\",\n        \"item\": {...},\n        \"patch\": [...],\n        \"execute_queue\": [...],\n        \"transitions_queue\": [...]\n        },\n        ...\n    ],\n    \"fqn\": \"tests.concurrency.test_concurrent_arg.ConcurrentLTM\",\n    \"params\": null,\n    \"structure\": {\n        ...\n    },\n    \"concurrent_instances\": {...},\n    \"created_at\": \"2024-09-01 21:32:43\",\n    \"updated_at\": \"2024-09-01 21:32:43\"\n}\n</code></pre> <pre><code>flou get 1\n</code></pre> Sample output<pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name       \u2503 fqn                \u2503 state   \u2503 params \u2503 structur\u2503 concurrent_instances \u2503 created_at          \u2503 uploaded_at         \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 sample_ltm \u2502 flou.app.SampleLTM \u2502 {       \u2502 None   \u2502 {       \u2502 {                    \u2502 2024-09-01 21:32:43 \u2502 2024-09-01 21:32:43 \u2502\n\u2502            \u2502                    \u2502     ... \u2502        \u2502     ... \u2502     ...              \u2502                     \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"documentation/engine/api-cli/#performing-a-transition","title":"Performing a transition","text":"<p>To perform a transition you need to know the transition <code>label</code>, it's <code>namespace</code>, your desired <code>params</code> and <code>payload</code>.</p> REST APICLI <pre><code>curl -X 'POST' \\\n    'http://localhost:8000/api/v0/ltm/1/transition' \\\n    -H 'accept: application/json' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n        \"transition\": \"sample_transition\",\n        \"namespace\": \"sample_ltm\",\n        \"params\": [],\n        \"payload\": {}\n    }'\n</code></pre> Sample output<pre><code>true\n</code></pre> <pre><code>flou transition 1 sample_transition\n</code></pre> Sample output<pre><code>Launched transition sample_ltm for LTM sample_ltm, id: 1 with payload: None\n</code></pre> <p>If you want a blocking call until another transition is performed un can use the <code>wait_until_transition</code> parameter that blocks the return until the transition you requested is performed. This way you can mimic a regular LLM call from your app and swap it to a Network of Agents without changing much of your app's code. Use the <code>namespace:label</code> format.</p> REST API <pre><code>curl -X 'POST' \\\n    'http://localhost:8000/api/v0/ltm/1/transition' \\\n    -H 'accept: application/json' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n        \"transition\": \"sample_transition\",\n        \"namespace\": \"sample_ltm\",\n        \"params\": [],\n        \"payload\": {},\n        \"wait_until_transition\": \"namespace:another_transition\",\n    }'\n</code></pre> Sample output<pre><code>true\n</code></pre>"},{"location":"documentation/engine/dependencies/","title":"Dependencies and configuration","text":"<p>Most Flou projects will need to install 3rd party Python packages to use in their Networks of Agents. As the orchestration engine runs inside Docker, Flou automatically handles the installation of the dependencies.</p>"},{"location":"documentation/engine/dependencies/#adding-dependencies-to-a-flou-project","title":"Adding dependencies to a Flou project","text":"<ol> <li>Create a <code>requirements.txt</code> file in the same folder as your <code>app.py</code></li> <li>Add any package you wish to install</li> <li>Restart the Flou Engine <code>flou compose restart engine</code></li> <li>Upon initialization the engine installs any new dependencies present in <code>requirements.txt</code></li> </ol>"},{"location":"documentation/engine/dependencies/#using-environment-variables","title":"Using environment variables","text":"<p>For different environments, project settings and 3rd party packages configuration you might need to set environment variables.</p> <ol> <li>Create a <code>.env</code> file in the same folder as your <code>app.py</code></li> <li> <p>Add pairs of <code>KEY=value</code> defining your environment variables, one per line. Variable names must be written in caps.  For example in the case of OpenAI API you can set:</p> <pre><code>OPENAI_API_KEY=sk-pro...\n</code></pre> </li> <li> <p>Inside your python scripts you can:</p> <pre><code>import os\nos.environ['OPENAI_API_KEY']\n</code></pre> </li> </ol>"},{"location":"documentation/engine/dependencies/#modifying-flous-settings","title":"Modifying Flou's settings","text":"<p>Flou's own settings can be overridden by <code>.env</code> files. For example you can set <code>APP_NAME</code> to modify the project's name that will appear in the Studio.</p> <p>You can see all the available settings in flou/conf.py.</p> <p>For nested configs use <code>__</code> (double underscore), for example <code>DATABASE__NAME</code>.</p>"},{"location":"documentation/engine/dependencies/#executor-settings","title":"Executor settings","text":""},{"location":"documentation/engine/dependencies/#max-retries","title":"Max retries","text":"<ul> <li>Type: Int</li> <li>Default: 1</li> <li>Description: You can set the maximum amount of retries for a certain execution by setting <code>EXECUTOR__MAX_RETRIES</code>. Each retry will be done with a jittery exponential backoff. For more information see Celery's documentation.</li> </ul>"},{"location":"documentation/engine/websockets/","title":"Websockets","text":"<p>Flou offers a websocket endpoint to keep up with your app up to date with an LTM execution and status in real-time.</p> <p>The websocket endpoint is: <code>ws://localhost:8000/ws/{ltm_id}</code> replacing <code>{ltm_id}</code> with the id of the ltm instance you want to subscribe to.</p> <p>Each websocket message returns the latest snapshot diff:</p> <pre><code>{\n    \"id\": {ltm_id},\n    \"snapshot\": {snapshot_patch}\n}\n</code></pre> <p>From the original LTM state you can apply successive snapshot patches to stay up to date with the latest state.</p>"},{"location":"documentation/engine/websockets/#using-the-websocket","title":"Using the websocket","text":"<p>To connect to the WebSocket, initiate a connection to <code>ws://localhost:8000/ws/{ltm_id}</code>. For example, using JavaScript:</p> <pre><code>const ltmId = 123;\n\n// get the LTM initial state\nconst ltmUrl = `http://localhost:8000/api/v0/ltm/${ltmId}`;\n\nlet ltm;\n\nlet getLtm = async () =&gt; {\n    await fetch(ltmUrl)\n        .then((response) =&gt; {\n            ltm = data.json();\n        })\n        .catch((error) =&gt; {\n            console.log(error);\n        });\n};\n\n// connect to the websocket to receive updates\nconst socket = new WebSocket(`ws://localhost:8000/ws/${ltmId}`);\n\nsocket.onopen = () =&gt; {\n    console.log(\"WebSocket connection established\");\n};\n\nsocket.onmessage = (event) =&gt; {\n    const data = JSON.parse(event.data.detail);\n\n    // append the new snapshot to the ltm data\n    ltm = { ...ltm, snapshots: [...ltm.snapshots, data.snapshot] };\n\n    let time = data.snapshot['time'];  // the server time at which the snapshot was taken\n    let reason = data.snapshot['reason'];  // the reason for the snapshot\n    let item = data.snapshot['item'];  // the details of the snapshot\n};\n\nsocket.onclose = () =&gt; {\n    console.log(\"WebSocket connection closed\");\n};\n</code></pre>"},{"location":"documentation/engine/websockets/#recreating-the-ltm-state-from-snapshots","title":"Recreating the LTM state from snapshots","text":"<p>From a list of snapshots patches we can recreate the latest state of the LTM. We will be using fast-json-patch to apply the patches consecutively.</p> <pre><code>let recreateState = () =&gt; {\n    let state = {};\n    for (snapshot in ltm.snapshots) {\n        jsonpatch.applyPatch(state, jsonpatch.deepClone(snapshot['patch']));\n    return state;\n};\n</code></pre>"},{"location":"documentation/network/","title":"Agents Network","text":"<p>The Network of Agents is Flou's main abstraction and data model. They are an orchestration layer to coordinate LLM prompts, tools and arbitrary code containing the logic and structure that LLM-powered apps need to focus on and iterate in order to achieve good production performance.</p> <p>They were designed to be able to express any kind of workflow from a simple unique prompt to complex workflows in a declarative way with clean, elegant and spaghetti free code.</p> <p>The Networks of Agents follows a code-first approach but in order to extract the best value it's recommended to use them with the visual representation and tools found in Flou Studio.</p> <p>In this section of the documentation you will learn:</p> <ol> <li>How to represent and implement your workflow in a State Machine</li> <li>Nesting Agents Networks for working with complex workflows</li> <li>Creating concurrent Agents Networks</li> </ol>"},{"location":"documentation/network/concurrency/","title":"Concurrency","text":"<p>Flou's Network of Agents were designed from the ground up to support concurrency enabling easy representation of complex workflows out-of-the-box with minimum latency.</p> <p>We have two types of concurrency. When a workflow forks into two or more distinct flows or when a workflow needs to be repeated several times concurrently.</p>"},{"location":"documentation/network/concurrency/#forking-a-workflow-into-different-flows","title":"Forking a workflow into different flows","text":"<p>When you need to execute many different tasks at the same time you just need to define a transition that has one outgoing LTM for each task.</p> Forking workflow example <p>You just need to replace the <code>to</code> parameter with an iterable of LTMs. In this case when <code>launch_tasks</code> is called <code>TaskA</code>, <code>TaskB</code> and <code>TaskC</code> statuses will be changed to <code>queued</code> and the Flou Engine will execute them concurrently.</p> Launching tasks concurrently example<pre><code>class ConcurrentMachine(LTM):\n    name = 'concurrent_machine'\n\n    init = [InitialState]\n    transitions = [\n        {\n            'label': 'launch_tasks',\n            'from': InitialState,\n            'to': [TaskA, TaskB, TaskC]\n        }\n    ]\n</code></pre>"},{"location":"documentation/network/concurrency/#running-an-ltm-several-times-concurrently","title":"Running an LTM several times concurrently","text":"<p>In some workflows or LLM patterns you need to run the same task several times with different parameters. For example, you need an LLM to process several uploaded files concurrently or you need to execute the same LLM prompt several times and choose the most common one (self-consistency) to achieve better performance.</p> <p>Flou makes this easy with parameterized transitions. Just like regular Python <code>f-strings</code> you can label your transitions and LTM names with named parameters and then launch a transition with a set of parameters. Each parameter name has to be surrounded by <code>{name}</code> curly brackets.</p> Parameterized transition example Launching parameterized transitions example<pre><code>class LaunchFilesProcessing(LTM):\n    name = \"launch_files_processing\"\n\n    def run(self, payload=None):\n        self.transition(\n            \"process_file_{file_id}\",\n            params=[{\"file_id\": \"1111\"}, {\"file_id\": \"2222\"}],\n        )\n\n\nclass ProcessingFile(LTM):\n    name = \"processing_file_{file_id}\"\n\n    def run(self, payload=None):\n        # processing code here\n        file_id = self.params['file_id']\n        ...\n\n\nclass ConcurrentProcessing(LTM):\n    name = \"concurrent_processing\"\n\n    init = [LaunchFilesProcessing]\n    transitions = [\n        {\n            \"from\": LaunchFilesProcessing,\n            \"label\": \"process_file_{file_id}\",\n            \"to\": ProcessingFile\n        }\n    ]\n</code></pre> <p>In this example when transitioning <code>process_file_{file_id}</code> with parameters <code>{\"file_id\": \"1111\"}, {\"file_id\": \"2222\"}]</code> two <code>ProcessingFile</code> will be launched with names: <code>processing_file_1111</code> and <code>processing_file_2222</code>.</p> <p>LTMs launched with parameterized transitions must have the same parameters in their names</p> <p>In this case <code>file_id</code> is the parameter name and it's present in the LTM name <code>processing_file_{file_id}</code> and the transition <code>process_file_{file_id}</code>.</p> <ul> <li>You can have as many parameters as needed in a parameterized transition.</li> <li>Use <code>self.params</code> to get the params of the current executing LTM.</li> <li>You can concurrently launch either States or sub State Machines.</li> <li>Each parameterized LTM has it's own local store accessible via <code>self.state</code>.</li> </ul>"},{"location":"documentation/network/concurrency/#joining-concurrent-flows","title":"Joining concurrent flows","text":"<p>If we want to join concurrent states after a fork we need a special State that handles the join. But first we need to understand how Flou handles updating the store.</p>"},{"location":"documentation/network/concurrency/#concurrently-updating-the-store","title":"Concurrently Updating the Store","text":"<p>When using concurrency you need to be very careful about updates to the store. Internally <code>update_state</code> updates the local memory store immediately but waits until the State execution finishes to update the database store atomically with just one call. This makes it difficult to work with concurrent stores when you have several LTMs updating it at the same time.</p> <p>For this use case you can use <code>LTM.atomic_state_append(key, value)</code> that atomically and immediately appends <code>value</code> to a pre initialized list <code>key</code> in <code>self.state</code> and returns the updated list. This can be used when joining concurrent forks.</p>"},{"location":"documentation/network/concurrency/#joining-forked-workflows","title":"Joining forked workflows","text":"Concurrency fork/join example <p>In this case we want <code>JoinTasks</code> to transition <code>done</code> only when <code>TaskA</code>, <code>TaskB</code> and <code>TaskC</code> have executed correctly.</p> <pre><code>class ConcurrentJoinMachine(LTM):\n    name = 'concurrent_join_machine'\n\n    init = [InitialState]\n    transitions = [\n        {'label': 'launch_tasks', 'from': InitialState, 'to': [TaskA, TaskB, TaskC]},\n        {'label': 'finished_task_a', 'from': TaskA, 'to': JoinTasks},\n        {'label': 'finished_task_b', 'from': TaskB, 'to': JoinTasks},\n        {'label': 'finished_task_c', 'from': TaskC, 'to': JoinTasks},\n        { 'label': 'done', 'from': JoinTasks, 'to': Finished},\n    ]\n\n    def get_initial_state(self):\n        return {'executed_tasks': []}\n</code></pre> <p>We now have 3 <code>finished_tasks</code> transitions from the 3 tasks to <code>JoinTasks</code>. We are initializing the store with an empty list <code>executed_tasks</code> that will store the tasks that have been already executed.</p> <p>We can use the transitions <code>payload</code> parameter to indicate which task has been executed and is transitioning.</p> <pre><code>class TaskA(LTM):\n    name = 'task_a'\n\n    def run(self, payload=None):\n        # run task A code\n        ...\n\n        self.transition('finished_task_a', payload='A')\n</code></pre> <p>Because <code>JoinTasks</code> will be called 3 times and possible at the same time we need to use <code>atomic_state_append</code> that will add an item to <code>executed_tasks</code> and return the new value atomically. This way we can guarantee that in only 1 of the 3 executions <code>executed_tasks</code> will have three items, hence only transitioning <code>done</code> once.</p> <p>Note that we get which task is calling <code>JoinTasks</code> by looking at the transaction payload.</p> <pre><code>class JoinTasks(LTM):\n    name = 'join_tasks'\n\n    def run(self):\n        executed_tasks = self.parent.atomic_state_append('executed_tasks', payload)\n        if set(executed_tasks) == set(('A', 'B', 'C')):\n            self.transition('done')\n</code></pre>"},{"location":"documentation/network/concurrency/#joining-parameterized-ltms","title":"Joining parameterized LTMs","text":"<p>For parameterized transitions we need to create a similar <code>Join</code> State but in this case we might not know which or how many parameters where transitioned. We need to save the launched <code>params</code> in the parent's store so we can retrieve them in the <code>Join</code>.</p> Concurrency parameters join example <pre><code>class LaunchFilesProcessing(LTM):\n    name = \"launch_files_processing\"\n\n    def run(self, payload):\n        uploaded_file_ids = payload['uploaded_file_ids']\n\n        self.parent.update_state('launched_params', uploaded_file_ids)\n\n        self.transition(\n            \"start_{file_id}\",\n            params=[\n                {\"file_id\": file_id}\n                for file_id in uploaded_file_ids\n            ],\n        )\n\n\nclass JoinProcessing(LTM):\n    name = 'join_processing'\n\n    def run(self):\n        processed_files = self.parent.atomic_state_append('processed_files', payload)\n        if set(processed_files) == set(self.parent.state['launched_params']):\n            self.transition('done')\n</code></pre>"},{"location":"documentation/network/nesting/","title":"Nesting","text":"<p>Flou's Network of Agents allows you to nest State Machines:</p> <ul> <li>keeping the code clean via encapsulating and decoupling</li> <li>creating reusable LLM patterns</li> <li>transforming a single prompt to it's own Network of Agents without changing the parent LTM</li> <li>allowing comparing network experiments while keeping the same State Machine interface</li> </ul> <p>As both States and State Machines share the same base class, you can create a nested Agents of Network simply by changing a State into it's own State Machine.</p> A sample nested LTM A sample nested LTM<pre><code>class Nested(LTM):\n    name = 'nested'\n    init = [NestedFirstState]\n    transitions = [\n        {\n            'label': 'continue',\n            'from': NestedFirstState,\n            'to': NestedSecondState,\n        },\n        {\n            'label': 'continue',\n            'from': NestedSecondState,\n            'to': NestedLastState,\n        },\n    ]\n\nclass Root(LTM):\n    name = 'root'\n    init = [InitialState]\n    transitions = [\n        {\n            'label': 'next',\n            'from': InitialState,\n            'to': Nested,\n        },\n        {\n            'label': 'finish',\n            'from': Nested,\n            'to': FinishState,\n        },\n\n    ]\n</code></pre> <p>Here you can see that <code>Root</code> executes <code>Nested</code> once <code>next</code> is transitioned. Transitioning to a nested LTM simply calls <code>start</code> on the inner LTM.</p> <p>As your Network of Agents becomes more complex and deeply nested collapsing and expanding LTMs in the visual representation in the Studio becomes a crucial tool.</p>"},{"location":"documentation/network/nesting/#accessing-ancestors-state-machines","title":"Accessing ancestors State Machines","text":"<p>When inside a child LTM State you may need to access ancestors machines. Flou gives you two ways of doing this:</p> <ul> <li><code>self.parent</code> which returns the parent State Machine. This is relative to the current State. You can call <code>self.parent.parent</code> recursively but it's not recommended to nest your logic to several nesting layers. Try to keep your logic relevant to the current and parent machine.</li> <li><code>self.root</code> which returns the root State Machine (in the case of multiple levels of nesting). This allows the root State Machine to act as a global store.</li> </ul>"},{"location":"documentation/network/nesting/#using-nested-stores","title":"Using nested stores","text":"<p>You can access the <code>root</code> or <code>parent</code> stores to share information between State Machines.</p> <ul> <li><code>self.parent.state</code> &amp; <code>self.parent.update_state(...)</code></li> <li><code>self.root.state</code> &amp; <code>self.root.update_state(...)</code></li> </ul>"},{"location":"documentation/network/nesting/#transition-namespaces","title":"Transition Namespaces","text":"<p>Flou creates transition namespaces for each State Machine, so the transitions are performed at just one LTM level and don't clash with one another. These namespaces are named by the Fully Qualified Name (FQN) of the LTM by joining the hierarchy LTM names with '.' (dots).</p> <p>In the above case we have 2 namespaces: <code>root</code> and <code>root.nested</code>. If we want <code>NestedLastState</code> to transition <code>finish</code> in <code>Root</code> we need to do it in the <code>root</code> namespace. We have 3 ways of achieving this:</p> <ul> <li> <p>by absolutely calling <code>transition</code> in the root machine:</p> <pre><code>self.root.transition(...)\n</code></pre> </li> <li> <p>by relatively using the parent:</p> <pre><code>self.parent.transition(...)\n</code></pre> </li> <li> <p>by explicitly passing the namespace as a parameter:</p> <pre><code>self.transition(..., namespace='root')\n</code></pre> </li> </ul> <p>Note that in this example all three are equivalent but this is not always the case</p> Transitioning parent State Machine<pre><code>class NestedLastState(LTM):\n    name = 'nested_last_state'\n\n    def run(self, payload=None):\n        # your code here\n        ...\n\n        # all three options are equivalent in this case\n        self.parent.transition('finish')\n        self.root.transition('finish')\n        self.transition('finish', namespace='root')\n</code></pre>"},{"location":"documentation/network/nesting/#custom-namespaces","title":"Custom namespaces","text":"<p>If you want to communicate arbitrary State Machines, you can do it by creating custom namespaces.</p> <pre><code>{\n    'label': 'transition_label',\n    'from': OneState,\n    'to': AnotherState,\n    'namespace': 'custom',\n}\n</code></pre> <p>This transition does not exist in the containing State Machine but in the <code>custom</code> namespace. The only way of performing this transition is by explicitly passing the namespace parameter:</p> <pre><code>self.transition('transition_label', namespace='custom')\n</code></pre> <p>This way you can perform transitions at a distance.</p>"},{"location":"documentation/network/nesting/#use-cases","title":"Use cases","text":""},{"location":"documentation/network/nesting/#decoupling-client-server-communication","title":"Decoupling client-server communication","text":"<p>A common practice is to encapsulate all the communication to the client in a separate LTM improving decoupling. Let's imagine que have a complex workflow with several stages in nested LTMs that can all talk with the client.</p> Decoupling communication example Decoupling communication example<pre><code>class Communication(LTM):\n    name = 'communication'\n\n    init = [WaitingForMessage]\n    transitions = [\n        {\n            'from': WaitingForMessage,\n            'to': SendingMessage,\n            'label': 'send_message',\n            'namespace': 'coms',\n        },\n        {\n            'from': SendingMessage,\n            'to': WaitingForMessage,\n            'label': 'message_sent',\n            'namespace': 'coms'\n        },\n    ]\n\n\nclass MyChatbot(LTM):\n    name = 'my_chatbot'\n\n    init = [Stage1, Communication]\n    transitions = [\n        {\n            'label': 'next_stage',\n            'from': Stage1,\n            'to': Stage2\n        },\n    ]\n</code></pre> <p>In this example, any State inside <code>Stage1</code> or <code>Stage2</code> can call <code>self.transition('send_message', namespace='coms')</code> to send a message to the client.</p>"},{"location":"documentation/network/nesting/#e2e-testing-simulating-an-user","title":"E2E testing (simulating an user)","text":"<p>If your workflow has many interactions with the user testing it E2E can be difficult. With Flou it's as easy as adding a new State Machine that simulates a synthetic user.</p> <p>Let's continuing with the previous example and add Synthetic User. By adding a new Synthetic User State Machine that listens to <code>message_sent</code> and <code>message_received</code> but in reverse we can simulate a user.</p> Synthetic user example <pre><code>class SyntheticUser(LTM):\n    name = 'synthetic_user'\n\n    transitions = [\n        {\n            'label': 'message_sent',\n            'from': UserWaitingForMessage,\n            'to': UserProcessingMessage,\n            'namespace': 'coms',\n        },\n        {\n            'label': 'message_received',\n            'from': UserProcessingMessage,\n            'to': UserWaitingForMessage,\n            'namespace': 'coms',\n        },\n    ]\n</code></pre> <p><code>UserProcessingMessage</code> can be Network of Agents as complex as you need it to be to successfully create all the needed messages for the E2E test.</p>"},{"location":"documentation/network/states-machines/","title":"States and Machines","text":"<p>The Agents Networks are State Machines. Its implementation is a Labelled Transition System called Labelled Transition Models (LTM). This design allows developers to experiment on the structure and transitions while tracking each change and provides several features out-of-the-box like: store management, nesting, concurrency and an execution time machine.</p> <p>Creating your application using Networks of agents helps you decouple your LLM/AI related code from the rest of your application.</p> <p>The LTMs are composed of States (units of code) that are orchestrated by a State Machine via transitions.</p>"},{"location":"documentation/network/states-machines/#states","title":"States","text":"<p>A State is a single computation unit. It can be any code, i.e. prompting an LLM, accessing third party APIs, manipulating data and launching transitions. The code runs when the state gets executed.</p> <p>Every State derives from the <code>LTM</code> base class and has a mandatory <code>name</code> and the corresponding code.</p> A sample State<pre><code>from flou.ltm import LTM\n\nclass ProcessingMessage(LTM):\n    name = 'processing_message'\n\n    def run(self, payload=None):\n        message = payload['message']\n        # process message here\n        ...\n</code></pre> <ul> <li><code>name</code> can be any lowercase string that starts with a letter and can contain numbers and underscores: <code>^[a-z][a-z0-9_]*$</code>. Each name must be unique.</li> <li> <p><code>run</code> receives an optional payload and can contain any code. To use third party packages you need to install them in the project's dependencies.</p> <p>Never call <code>run</code> manually</p> <p><code>run</code> should never be called manually, the State Machine handles every execution.</p> </li> </ul> <p>Just one State is enough to use Flou, this is the most simple case from which you can build upon.</p>"},{"location":"documentation/network/states-machines/#noop-state","title":"Noop State","text":"<p>A special case of States are the no-operation (Noop) States that don't have any code associated with them. They are used to represent an idle state waiting for a transition.</p> <pre><code>class IdeState(LTM):\n    name = 'idle_state'\n</code></pre>"},{"location":"documentation/network/states-machines/#state-machines","title":"State Machines","text":"<p>The Flou State Machines capture the structure of the Agents Network defining it's States transitions. As with the States, they inherit from LTM and must have an unique name.</p> <p>Let's create a sample Agents Network/State Machine for a simple chatbot.</p> A sample chatbot Agents Network A sample chatbot State Machine<pre><code>from flou.ltm import LTM\nfrom flou.registry import registry\n\nclass MyChatbot(LTM):\n    name = 'my_chatbot'\n\n    init = [WaitingForMessage]\n    transitions = [\n        {\n            'label': 'message_received',\n            'from': WaitingForMessage,\n            'to': ProcessingMessage\n        },\n        {\n            'label': 'send_message',\n            'from': ProcessingMessage,\n            'to': SendingMessage\n        },\n        {\n            'label': 'message_sent',\n            'from': SendingMessage,\n            'to': WaitingForMessage\n        },\n    ]\n\nregistry.register(MyChatbot)\n</code></pre> <ul> <li>As with a State each State Machine needs an unique name.</li> <li><code>init</code> is a list of States classes that will get executed when the State Machine starts.</li> <li><code>transitions</code> is a list of dictionaries indicating each transition with a <code>label</code>, a <code>from</code> State and a <code>to</code> State.</li> <li><code>registry.register</code> adds this State Machine to Flou.</li> </ul> <p>In this chatbot example we have three States:</p> <ul> <li><code>WaitingForMessage</code> is an initial State, when the State Machine starts it will execute this state. In this case <code>WaitingForMessage</code> can be an idle State.</li> <li><code>ProcessingMessage</code> receives the user's message and processes it to generate a response. Here's where you would call your LLM.</li> <li><code>SendingMessage</code> encapsulates all the logic needed to send the message to the client UX. Keeping this State separate from processing the message decouples the LLM-related and communication-related code maintaining separation of concerns maintaining separation of concerns.</li> </ul>"},{"location":"documentation/network/states-machines/#starting-a-state-machine","title":"Starting a State Machine","text":"<p>To start a State Machine it's as easy as creating an instance and running <code>start</code>.  Notice it should be run only once.</p> <pre><code>chatbot = MyChatbot()\nid = chatbot.start()\n</code></pre> <p>The resulting <code>id</code> is unique and can later be used in the API to reference the created instance.</p>"},{"location":"documentation/network/states-machines/#state-statuses","title":"State statuses","text":"<p>When running a State Machine each State get's a status. The possible status are:</p> <ul> <li><code>init</code>: the state has been initialized but is not yet queued for execution.</li> <li><code>queued</code>: the state is pending execution by the Flou engine.</li> <li><code>active</code>: the state has been executed and can now transition.</li> <li><code>completed</code>: the state has been executed and an outgoing transition has been performed.</li> </ul>"},{"location":"documentation/network/states-machines/#transitioning","title":"Transitioning","text":"<p>Each transition has a <code>from</code> and <code>to</code> parameters. When a transition is performed the State Machine looks for every possible transitions of States that are in the <code>active</code> status. This means the State can transition onto a new State, changing the <code>from</code> State status to <code>completed</code> and the <code>to</code> State status to <code>queued</code>.</p> <p>Warning</p> <p>Performing a transition with no outgoing States in an <code>active</code> status results in an error.</p> <p>Calling a transition:</p> Performing a transition<pre><code>chatbot.transition('message_received', payload={'message': message})\n</code></pre> <p>The <code>transition</code> signature is:</p> <pre><code>LTM.transition(label, payload=None, params=None, namespace=None)\n</code></pre> <p>For more information on <code>params</code> and <code>namespace</code> check Nesting and Concurrency.</p> <p>The transitions are performed after the State has finishes executing</p> <p>The order in which you execute code in <code>run</code> and call <code>self.transition</code> does not matter. The transitions are gather and only performed once the State has successfully executed.</p>"},{"location":"documentation/network/states-machines/#attaching-data-to-a-transition-payload","title":"Attaching data to a Transition (Payload)","text":"<p>When a transition should have data attached to it you can send them via the <code>payload</code> parameter. In the case of our chatbot <code>message_received</code> and <code>message_sent</code> can use this feature:</p> <pre><code>chatbot.transition(`message_received`, payload={'message': \"A message\"})\n</code></pre> <p>The payload can be any serializable python data structure.</p> <p>Payloads are great for data that is strictly related to a single transition since they aren't stored in a permanent fashion.</p>"},{"location":"documentation/network/states-machines/#store-management","title":"Store Management","text":"<p>Flou provides a data store out-of-the-box. Each State Machine has a store that any State can access and each State has it's own local store.</p> Sample Store code<pre><code>class MyState(LTM):\n    name = 'my_state'\n\n    def get_initial_state(self):\n        return {\n            \"key1\": \"example\",\n            \"key2\": \"other\",\n        }\n\n    def run(self, payload=None):\n        self.state  # local State store\n        # returns {\n        #     \"key1\": \"example\",\n        #     \"key2\": \"other\",\n        # }\n\n        self.root.state\n        # returns the State Machine global store\n</code></pre> <p><code>state</code> will be renamed <code>store</code> in upcoming releases</p> <p>Every <code>LTM</code> has a function <code>get_initial_state</code> that is used during the State initialization to create it's local store. It must return a dictionary. Keys cannot start with <code>_</code> (underscore) as they are reserved for Flou internal properties.</p> <p>Using <code>self.state</code> you can retrieve the store of the current State.</p> <p>Using <code>self.root.state</code> you can access the global store of the State Machine.</p>"},{"location":"documentation/network/states-machines/#modifying-the-store","title":"Modifying the store","text":"<p>Don't attempt to directly modify <code>.state</code>, use <code>.update_state()</code> instead</p> <p>As Flou is prepared for concurrency in order to update the store you need to use the special function <code>update_state</code>.</p> <p>To update the store use the special function <code>update_state</code> which expects a dictionary. This creates or overwrites the desired keys.</p> <p>To update a nested key in the store you need to use the Qualified Name of the path to access that key separated by <code>.</code> (dots). For example:</p> <pre><code>def run(self, payload=None):\n    self.state\n    # returns {}\n\n    self.state['key'] = {'a': 1, 'b': 1}\n    # **INVALID**, use `update_state`\n\n    self.update_state({'key': {'a': 1, 'b': 2}})\n    # updates the state\n\n    self.state\n    # returns {'key': {'a': 1, 'b': 1}}\n\n    self.update_state({'key': {'a': 3})\n    # replaces `key` with `{'a': 1}`\n\n    # use instead\n    self.update_state({'key.a': {'a': 3})  # replaces ['key']['a'] with {'a': 1}\n</code></pre> <p>Changes to the store are not immediately committed to the database</p> <p>When calling <code>update_state</code> the in memory store get's updated but the database isn't updated until the State code is executed successfully. This keeps the State execution in an atomic transaction.</p>"},{"location":"documentation/studio/","title":"Studio","text":"<p>The Flou Studio is an integral part of the framework. It let's you work with your Networks of Agents interactively and visually greatly improving the developer UX.</p> <p>You can access the Studio visiting http://localhost:8001/.</p>"},{"location":"documentation/studio/#visual-representation","title":"Visual representation","text":"<p>With the Studio's visual representation you can navigate your LTMs viewing the whole structure at a glance making it much easier to form a mental model of complex Networks of Agents. By clicking in a State you can see additional properties in a tooltip.</p> <p>Each State status has an unique color and you can see the current transition/execution by an animated dashed line.</p> <p>You can collapse and expand nested LTMs by clicking in the collapse/expand icon. Double clicking on a sub LTM zooms into that particular sub LTM isolating it and letting you work on just parts of the network.</p> Collapsing and Expanding LTMs <p>When working with parameterized LTMs and concurrency you can click on a parameterized State to see every spawned instance and zoom into one.</p> Parameterized instances"},{"location":"documentation/studio/#inspect","title":"Inspect","text":"<p>The Inspect section of the Studio can be used for observability and inspection of production traces of your LTMs. You can list every executed LTM and see the details of a particular one.</p> <p>The inspector updates in real-time as your LTM executes.</p>"},{"location":"documentation/studio/#execution-history-snapshots","title":"Execution history (snapshots)","text":"Snapshots table <p>The Flou Engine saves a snapshot of you LTMs at every State execution and performed transition. In the Studio you can navigate the execution history at any point in time.</p> <p>You can see an ordered list of every snapshots to trace and inspect the execution and see the State statuses and store values and how they evolved.</p>"},{"location":"documentation/studio/#store-inspection","title":"Store inspection","text":"Store <p>At any point in time you can inspect a snapshot of the internal store of the LTM (and any sub State) or see what particular changes (diff) were made to the store in that snapshot.</p>"},{"location":"documentation/studio/#playground","title":"Playground","text":"<p>In the Studio's playground you can not only inspect an LTM but interact with it, modifying it's state. You can either create an LTM instance from scratch (Playgroud &gt; + New LTM) or inspect a production LTM and \"Copy and Open LTM in Playground\" to interact with it.</p>"},{"location":"documentation/studio/#transition","title":"Transition","text":"Transition form <p>You can manually perform a transition by filling the <code>label</code>, <code>namespace</code> and optional <code>params</code> and <code>payload</code> in the transition form. The transition and executions will be updated in real-time.</p>"},{"location":"documentation/studio/#rollback-replay","title":"Rollback &amp; Replay","text":"<p>When developing a Network of Agents it's common practice to retry certain steps, i.e. calls to LLM models. Flou is equipped with rollbacks to go back to any point in time and continue the execution from that point onwards. It also let's you replay a certain transition so you don't need to manually input that transition again.</p> Rollback &amp; Replay buttons <p>Flou is designed so it never looses any information; when performing a rollback it gets saved and you can \"undo\" any rollback you have performed keeping the whole execution history.</p> Rollbacks history"},{"location":"getting-started/","title":"Creating a Flou project","text":"<ol> <li> <p>Install <code>docker engine</code> if not already present.</p> </li> <li> <p>Create a new folder for your Flou project:</p> <pre><code>% mkdir my-project\n% cd my-project\n</code></pre> </li> <li> <p>Start a Python virtual environment and install Flou:</p> <pre><code>% python3 -m venv venv\n% source venv/bin/activate\n(venv) % pip install flou\n</code></pre> </li> <li> <p>Create an <code>app.py</code> file, the entrypoint for your Flou project and a <code>requirements.txt</code> file for your project dependencies:</p> <pre><code>(venv) % touch app.py\n(venv) % touch requirements.txt\n</code></pre> </li> <li> <p>Start Flou:</p> <pre><code>(venv) % flou compose up\n</code></pre> <p>Flou uses docker under the hood</p> <p>Flou uses <code>docker compose</code> to easily manage all the needed processes with a friendly wrapper via <code>flou compose</code>.</p> <p>Flou is currently private</p> <p>To run Flou you will need to run it in development mode or run a local docker registry.</p> </li> <li> <p>Open the Flou Studio by visiting http://localhost:8001 .</p> </li> <li> <p>You can find the Flou Api documentation in http://localhost:8000/docs .</p> </li> </ol>"},{"location":"getting-started/first-network/","title":"Creating a sample Agents Network","text":"<p>An Agents Network is the brain of your LLM app. It's a network of LLM model prompts, tools and arbitrary procedures structured in a state machine. Achieving great performance on your Agents Network is an iterative process.</p> <p>Let's create a sample Newtork to get you started.</p> A simple Agents Network <p>Copy the following code into your <code>app.py</code>:</p> app.py<pre><code>from flou.ltm import LTM\nfrom flou.registry import registry\n\n\nclass FirstState(LTM):\n    name = 'first_state'\n\n    def run(self, payload=None):\n        self.transition('continue')\n\n\nclass SecondState(LTM):\n    name = 'second_state'\n\n\nclass MyNetwork(LTM):\n    name = 'root'\n    init = [FirstState]\n    transitions = [{'from': FirstState, 'label': 'continue', 'to': SecondState}]\n\n\nregistry.register(MyNetwork)\n</code></pre> <p>Let's break this down.</p>"},{"location":"getting-started/first-network/#defining-basic-states","title":"Defining basic States","text":"<p>A State is the atomic unit of Flou. It get's executed by the Flou Engine when transitioned to. It contains the prompts to LLMs, executing arbitrary code, etc.</p> A simple State<pre><code>class FirstState(LTM):\n    name = 'first_state'\n\n    def run(self, payload=None):\n        self.transition('continue')\n</code></pre> <ul> <li><code>LTM</code> is the base class from where all states and machines inherit. You always   need to define a <code>name</code> property.</li> <li>The <code>run</code> method contains the code that runs when the state executes.</li> <li><code>self.transition(label)</code> indicates the Flou engine to transition every   active state that has an outgoing <code>label</code> transition.</li> </ul> A final State<pre><code>class SecondState(LTM):\n    name = 'second_state'\n</code></pre> <ul> <li>This state is a <code>noop</code> (no operation) State. It doesn't run any code.</li> </ul>"},{"location":"getting-started/first-network/#defining-a-state-machine","title":"Defining a State Machine","text":"<p>A Network is the orchestration layer of States. It establishes the transitions between the states and specifies the initial States.</p> The State Machine<pre><code>class MyNetwork(LTM):\n    name = 'root'\n    init = [FirstState]\n    transitions = [{'from': FirstState, 'label': 'continue', 'to': SecondState}]\n</code></pre> <ul> <li><code>MyNetwork</code> is a State Machine called <code>root</code>.</li> <li><code>init</code> specifies which are the <code>initial</code> states that need to be run when the   Machine starts.</li> <li><code>transitions</code> is a list of transitions that indicate the labelled relations   between the states. In this case we have just one transition from <code>FirstState</code>   to <code>SecondState</code> labelled <code>continue</code>.</li> </ul>"},{"location":"getting-started/first-network/#registering-your-agents-network","title":"Registering your Agents Network","text":"Registering the Agents Network<pre><code>registry.register(MyNetwork)\n</code></pre> <ul> <li>By registering <code>MyNetwork</code> we make it available for the Flou Engine &amp; Studio.</li> </ul>"},{"location":"getting-started/studio/","title":"Using the Flou Studio","text":"<p>Now that we have created and registered our first Agents Network it's time to play with it.</p> <ul> <li>Open the Flou Studio visiting http://localhost:8001  and go to the Playground.</li> <li>On the top right select + New LTM.</li> <li>Select your newly created <code>MyNetwork</code> and Create.</li> </ul> <p>Great! You have created the first instance of your Agents Network.</p> <ul> <li>You can see the visual representation of your Network.</li> <li>Navigate all the snaphots, i.e. the Network execution history and State.</li> <li>Execute new transitions.</li> <li>Visualize the internal state.</li> <li>Perform rollbacks to a previous point in time.</li> </ul>"},{"location":"getting-started/studio/#next-steps","title":"Next steps","text":"<p>Now that you have created a sample Agent Network and created it's first instance it's time to start iterating your Network.</p> <p>Continue reading more about the Agents Networks.</p>"},{"location":"tutorial/","title":"Flou's Tutorial","text":"<p>During this Tutorial you will learn how to use Flou in a real project, starting with a PoC, adding features and improving the performance. By the end of the Tutorial you will be able to work on your own project.</p> <p>We will be creating a daily children's stories project.</p> <p>It's divided in 3 parts:</p> <ol> <li>Part 1: Writing a story</li> <li>Part 2: Daily customized stories</li> </ol>"},{"location":"tutorial/part-1/","title":"Tutorial part 1: creating a PoC","text":""},{"location":"tutorial/part-2/","title":"Part 2","text":"<p>Onboarding     Questionnaire     Tell us about your child/children     What age are they? What do they like?     What kind of stories do they like?     How long does it take them to fall asleep?</p> <p>Buttons: Tell me a Story I want a personalized story     write like a chatbot     suggestions         genre: adventure, police, love         setting:         characters: unicorns,         Be as creative as you like. Continue last story/yesterday's story Continue a previous story Modify settings -&gt; edits the settings</p> <p>During a story -&gt; edit a story from the current scroll onwards Show where it was edited from At the end of the story a textbox:     Did you like it or not? What would you change? Anything for next time?</p>"}]}